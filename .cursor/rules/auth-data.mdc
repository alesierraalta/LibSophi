---
globs: **/auth/**/*,**/supabase/**/*,**/stores/**/*
description: "Authentication and data management patterns for Palabreo"
---

# Authentication & Data Management

## 🔐 Authentication Architecture

### Supabase + NextAuth.js Integration
```typescript
// lib/auth/config.ts
import { NextAuthOptions } from 'next-auth'
import { SupabaseAdapter } from '@next-auth/prisma-adapter'
import { createClient } from '@supabase/supabase-js'

export const authOptions: NextAuthOptions = {
  adapter: SupabaseAdapter({
    url: process.env.NEXT_PUBLIC_SUPABASE_URL!,
    secret: process.env.SUPABASE_SERVICE_ROLE_KEY!,
  }),
  providers: [
    // OAuth providers
  ],
  callbacks: {
    session: ({ session, token }) => ({
      ...session,
      user: {
        ...session.user,
        id: token.sub,
      },
    }),
  },
}
```

### Client-Side Authentication
```typescript
// hooks/useAuth.ts
import { useSession, signIn, signOut } from 'next-auth/react'
import { useAuthStore } from '@/lib/stores/auth-store'

export function useAuth() {
  const { data: session, status } = useSession()
  const { setUser, clearUser } = useAuthStore()
  
  const login = async (provider: string) => {
    await signIn(provider)
  }
  
  const logout = async () => {
    await signOut()
    clearUser()
  }
  
  return {
    user: session?.user,
    isAuthenticated: !!session,
    isLoading: status === 'loading',
    login,
    logout,
  }
}
```

## 🗄️ Supabase Client Configuration

### Browser Client
```typescript
// lib/supabase/browser.ts
import { createBrowserClient } from '@supabase/ssr'

export const createClient = () =>
  createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
```

### Server Client
```typescript
// lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export const createClient = () => {
  const cookieStore = cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: any) {
          cookieStore.set({ name, value, ...options })
        },
        remove(name: string, options: any) {
          cookieStore.set({ name, value: '', ...options })
        },
      },
    }
  )
}
```

### Middleware Configuration
```typescript
// lib/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: any) {
          response.cookies.set({ name, value, ...options })
        },
        remove(name: string, options: any) {
          response.cookies.set({ name, value: '', ...options })
        },
      },
    }
  )

  await supabase.auth.getUser()
  return response
}
```

## 🏪 State Management with Zustand

### Auth Store
```typescript
// lib/stores/auth-store.ts
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface User {
  id: string
  email: string
  name: string
  avatar?: string
}

interface AuthState {
  user: User | null
  isAuthenticated: boolean
  setUser: (user: User) => void
  clearUser: () => void
  updateUser: (updates: Partial<User>) => void
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      isAuthenticated: false,
      
      setUser: (user) => set({ user, isAuthenticated: true }),
      
      clearUser: () => set({ user: null, isAuthenticated: false }),
      
      updateUser: (updates) => {
        const currentUser = get().user
        if (currentUser) {
          set({ user: { ...currentUser, ...updates } })
        }
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({ user: state.user, isAuthenticated: state.isAuthenticated }),
    }
  )
)
```

### Works Store
```typescript
// lib/stores/works-store.ts
import { create } from 'zustand'

interface Work {
  id: string
  title: string
  content: string
  author_id: string
  created_at: string
  updated_at: string
  published: boolean
}

interface WorksState {
  works: Work[]
  currentWork: Work | null
  isLoading: boolean
  
  setWorks: (works: Work[]) => void
  addWork: (work: Work) => void
  updateWork: (id: string, updates: Partial<Work>) => void
  deleteWork: (id: string) => void
  setCurrentWork: (work: Work | null) => void
  setLoading: (loading: boolean) => void
}

export const useWorksStore = create<WorksState>((set, get) => ({
  works: [],
  currentWork: null,
  isLoading: false,
  
  setWorks: (works) => set({ works }),
  
  addWork: (work) => set((state) => ({ 
    works: [work, ...state.works] 
  })),
  
  updateWork: (id, updates) => set((state) => ({
    works: state.works.map(work => 
      work.id === id ? { ...work, ...updates } : work
    ),
    currentWork: state.currentWork?.id === id 
      ? { ...state.currentWork, ...updates }
      : state.currentWork
  })),
  
  deleteWork: (id) => set((state) => ({
    works: state.works.filter(work => work.id !== id),
    currentWork: state.currentWork?.id === id ? null : state.currentWork
  })),
  
  setCurrentWork: (work) => set({ currentWork: work }),
  setLoading: (loading) => set({ isLoading: loading }),
}))
```

## 🔒 Route Protection

### Auth Guard Component
```typescript
// components/AuthGuard.tsx
'use client'

import { useAuth } from '@/hooks/useAuth'
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'

interface AuthGuardProps {
  children: React.ReactNode
  redirectTo?: string
  requireAuth?: boolean
}

export default function AuthGuard({ 
  children, 
  redirectTo = '/login',
  requireAuth = true 
}: AuthGuardProps) {
  const { isAuthenticated, isLoading } = useAuth()
  const router = useRouter()
  
  useEffect(() => {
    if (!isLoading) {
      if (requireAuth && !isAuthenticated) {
        router.push(redirectTo)
      } else if (!requireAuth && isAuthenticated) {
        router.push('/main')
      }
    }
  }, [isAuthenticated, isLoading, requireAuth, redirectTo, router])
  
  if (isLoading) {
    return <div className="flex items-center justify-center min-h-screen">
      Loading...
    </div>
  }
  
  if (requireAuth && !isAuthenticated) {
    return null
  }
  
  if (!requireAuth && isAuthenticated) {
    return null
  }
  
  return <>{children}</>
}
```

### Middleware Protection
```typescript
// middleware.ts
import { type NextRequest } from 'next/server'
import { updateSession } from '@/lib/supabase/middleware'

export async function middleware(request: NextRequest) {
  // Update Supabase session
  const response = await updateSession(request)
  
  // Protected routes
  const protectedRoutes = ['/main', '/profile', '/writer', '/mis-obras']
  const authRoutes = ['/login', '/register']
  
  const isProtectedRoute = protectedRoutes.some(route => 
    request.nextUrl.pathname.startsWith(route)
  )
  
  const isAuthRoute = authRoutes.some(route =>
    request.nextUrl.pathname.startsWith(route)
  )
  
  // Add your auth logic here
  // This is handled by the AuthGuard component on client side
  
  return response
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

## 📊 Data Fetching Patterns

### Server Actions
```typescript
// lib/actions/works.ts
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

export async function createWork(formData: FormData) {
  const supabase = createClient()
  
  const title = formData.get('title') as string
  const content = formData.get('content') as string
  
  const { data, error } = await supabase
    .from('works')
    .insert([{ title, content }])
    .select()
    .single()
  
  if (error) {
    throw new Error(error.message)
  }
  
  revalidatePath('/mis-obras')
  return data
}

export async function updateWork(id: string, updates: Partial<Work>) {
  const supabase = createClient()
  
  const { data, error } = await supabase
    .from('works')
    .update(updates)
    .eq('id', id)
    .select()
    .single()
  
  if (error) {
    throw new Error(error.message)
  }
  
  revalidatePath('/mis-obras')
  return data
}
```

### Client-Side Data Fetching
```typescript
// hooks/useWorks.ts
import { useEffect } from 'react'
import { useWorksStore } from '@/lib/stores/works-store'
import { createClient } from '@/lib/supabase/browser'

export function useWorks() {
  const { works, setWorks, setLoading } = useWorksStore()
  const supabase = createClient()
  
  useEffect(() => {
    const fetchWorks = async () => {
      setLoading(true)
      
      const { data, error } = await supabase
        .from('works')
        .select('*')
        .order('created_at', { ascending: false })
      
      if (error) {
        console.error('Error fetching works:', error)
      } else {
        setWorks(data || [])
      }
      
      setLoading(false)
    }
    
    fetchWorks()
    
    // Subscribe to real-time updates
    const subscription = supabase
      .channel('works_changes')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'works' },
        (payload) => {
          console.log('Work updated:', payload)
          fetchWorks() // Refetch data on changes
        }
      )
      .subscribe()
    
    return () => {
      subscription.unsubscribe()
    }
  }, [setWorks, setLoading, supabase])
  
  return { works }
}
```

## 🧪 Testing Data Management

### Database Cleanup for Tests
```typescript
// lib/test-utils.ts
import { createClient } from '@/lib/supabase/server'

export async function cleanupTestData() {
  const supabase = createClient()
  
  // Clean up test works
  await supabase
    .from('works')
    .delete()
    .like('title', '%test%')
  
  // Clean up test users
  await supabase
    .from('users')
    .delete()
    .like('email', '%test%')
  
  // Reset auto-increment values if needed
  // This depends on your database setup
}

export async function createTestUser() {
  const supabase = createClient()
  
  const testUser = {
    email: 'test@example.com',
    name: 'Test User',
  }
  
  const { data, error } = await supabase
    .from('users')
    .insert([testUser])
    .select()
    .single()
  
  if (error) throw error
  
  return data
}
```

### Test Database Transactions
```typescript
// Use database transactions for test isolation
export async function withTransaction<T>(
  callback: (client: SupabaseClient) => Promise<T>
): Promise<T> {
  const supabase = createClient()
  
  try {
    // Start transaction
    const result = await callback(supabase)
    
    // Commit on success
    return result
  } catch (error) {
    // Rollback on error
    throw error
  }
}
```

## 🔄 Real-time Features

### Real-time Subscriptions
```typescript
// hooks/useRealtimeWorks.ts
import { useEffect } from 'react'
import { createClient } from '@/lib/supabase/browser'
import { useWorksStore } from '@/lib/stores/works-store'

export function useRealtimeWorks() {
  const { addWork, updateWork, deleteWork } = useWorksStore()
  
  useEffect(() => {
    const supabase = createClient()
    
    const subscription = supabase
      .channel('works_realtime')
      .on('postgres_changes', 
        { event: 'INSERT', schema: 'public', table: 'works' },
        (payload) => {
          addWork(payload.new as Work)
        }
      )
      .on('postgres_changes',
        { event: 'UPDATE', schema: 'public', table: 'works' },
        (payload) => {
          updateWork(payload.new.id, payload.new as Partial<Work>)
        }
      )
      .on('postgres_changes',
        { event: 'DELETE', schema: 'public', table: 'works' },
        (payload) => {
          deleteWork(payload.old.id)
        }
      )
      .subscribe()
    
    return () => {
      subscription.unsubscribe()
    }
  }, [addWork, updateWork, deleteWork])
}
```

This authentication and data management system provides secure, scalable, and maintainable patterns for user authentication, data persistence, and real-time features in the Palabreo platform.